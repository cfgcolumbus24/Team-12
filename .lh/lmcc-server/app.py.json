{
    "sourceFile": "lmcc-server/app.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1730539205439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730539674233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,56 @@\n+from flask import Flask, request, jsonify, make_response\n+import openai\n+import os\n+import logging\n+\n+from flask_cors import CORS\n+\n+app = Flask(__name__)\n+CORS(app)\n+\n+\n+class OpenAIFacade:\n+    def __init__(self):\n+        self.client = openai.OpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])\n+        self.system_message = \"You are an AI Specialist that specilaizing in choosing tags for a certain description. Given a description and a set of tags please return all relevent tags ordered by the most confident (first is most condifedent). please return tags seperated by commas. If you cannot find any assocaited tags please just return 1 tag General Here are the Tags you can choose from (Art, Music, Film, Dance, Guitar, Performance, Painting, Piano, Singing, Landscape, and Photography)\"\n+\n+    def parse_response(self, response):\n+        try:\n+            tags = response.split(\",\")\n+\n+            data = {\"message\": tags, \"code\": \"SUCCESS\"}\n+            return make_response(jsonify(data), 200)\n+\n+        except Exception as e:\n+            logging.error(f\"Error parsing response: {e}\")\n+            return make_response(\n+                jsonify({\"message\": \"Error parsing response\", \"code\": \"ERROR\"}), 500\n+            )\n+\n+    def get_gpt4_response(self, prompt):\n+        try:\n+            if not isinstance(prompt, str):\n+                raise ValueError(\"The prompt must be a string.\")\n+\n+            response = self.client.chat.completions.create(\n+                model=\"gpt-4\",\n+                messages=[\n+                    {\"role\": \"system\", \"content\": self.system_message},\n+                    {\"role\": \"user\", \"content\": prompt},\n+                ],\n+            )\n+            content = response.choices[0].message.content.strip()\n+            return self.parse_response(content)\n+\n+        except Exception as e:\n+            logging.error(f\"Failed to get GPT-4 response from OpenAI: {e}\")\n+            data = {\"message\": f\"Failed to return LLM Response: {e}\", \"code\": \"ERROR\"}\n+            return make_response(jsonify(data), 500)\n+\n+\n+@app.route(\"/getAI\", methods=[\"POST\"])\n+def get_ai_response():\n+    data = str(request.get_json())\n+    openai_facade = OpenAIFacade()\n+\n+    return openai_facade.get_gpt4_response(data)\n"
                }
            ],
            "date": 1730539205439,
            "name": "Commit-0",
            "content": "from flask import Flask, request, jsonify, make_response\nimport openai\nimport os\nimport logging\n\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)\n\n\nclass OpenAIFacade:\n    def __init__(self):\n        self.client = openai.OpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])\n        self.system_message = \"You are an AI Specialist that specilaizing in choosing tags for a certain description. Given a description and a set of tags please return all relevent tags ordered by the most confident (first is most condifedent). please return tags seperated by commas. If you cannot find any assocaited tags please just return 1 tag General Here are the Tags you can choose from (Art, Music, Film, Dance, Guitar, Performance, Painting, Piano, Singing, Landscape, and Photography)\"\n\n    def parse_response(self, response):\n        try:\n            tags = response.split(\",\")\n\n            data = {\"message\": tags, \"code\": \"SUCCESS\"}\n            return make_response(jsonify(data), 200)\n\n        except Exception as e:\n            logging.error(f\"Error parsing response: {e}\")\n            return make_response(\n                jsonify({\"message\": \"Error parsing response\", \"code\": \"ERROR\"}), 500\n            )\n\n    def get_gpt4_response(self, prompt):\n        try:\n            if not isinstance(prompt, str):\n                raise ValueError(\"The prompt must be a string.\")\n\n            response = self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": self.system_message},\n                    {\"role\": \"user\", \"content\": prompt},\n                ],\n            )\n            content = response.choices[0].message.content.strip()\n            return self.parse_response(content)\n\n        except Exception as e:\n            logging.error(f\"Failed to get GPT-4 response from OpenAI: {e}\")\n            data = {\"message\": f\"Failed to return LLM Response: {e}\", \"code\": \"ERROR\"}\n            return make_response(jsonify(data), 500)\n\n\n@app.route(\"/getAI\", methods=[\"POST\"])\ndef get_ai_response():\n    data = str(request.get_json())\n    openai_facade = OpenAIFacade()\n\n    return openai_facade.get_gpt4_response(data)\n"
        }
    ]
}